{
  "messages": [
    {
      "role": "system",
      "content": "PROJECT OVERVIEW:\nFlow is a framework-agnostic code intelligence platform that builds accurate business and technical flow diagrams from source code and runtime execution. It helps new developers and product teams understand a large codebase by generating a multi-level, zoomable flow graph.\n\nARCHITECTURE PRINCIPLES:\n1. flow-adapter-java extracts a pure static call graph (methods, method calls, classes, files). It must remain 100% framework-agnostic.\n2. Static plugins add semantic meaning. These are separate modules:\n   - flow-plugin-spring: detects controllers, request mappings, bean annotations, static event listeners.\n   - flow-plugin-kafka: detects @KafkaListener and static KafkaTemplate.send() calls.\n   Static plugins run only in the scanner/CLI environment.\n3. Runtime plugins are separate modules that run inside the target Spring Boot application:\n   - flow-runtime-spring: AOP for actual method execution, DI resolution, startup environment resolution.\n   - flow-runtime-kafka: runtime KafkaTemplate.send() interception, listener topic resolution.\n   These emit runtime events to Flow Core.\n4. Flow Core merges static graph + runtime events and produces layered graphs for zoom levels (business → service → method → raw → runtime). Graph is stored in a graph database (e.g., Neo4j).\n5. flow-runner is a CLI tool that loads static plugins via ServiceLoader and generates the static graph output (GEF format).\n\nABSOLUTE RULES:\n- flow-adapter-java must not depend on Spring, Kafka, or any framework.\n- Static plugins contain NO runtime AOP, NO tracing, NO Spring Boot code.\n- Runtime plugins contain NO static code analysis logic.\n- Plugin discovery uses Java ServiceLoader.\n- All modules must follow clean separation: adapter → static plugins → runtime plugins → core.\n\nDEVELOPER GUIDANCE:\nWhen generating code, Copilot should:\n- Keep adapter code simple, using JavaParser for AST-based static extraction.\n- Place any framework annotation parsing inside static plugin modules.\n- Place any AOP, Java Agent, ByteBuddy, or runtime interception code inside runtime plugin modules.\n- Ensure consistent GEF JSON output format for graph nodes and edges.\n- Use clear extension points (FlowStaticPlugin, FlowRuntimePlugin).\n- Help maintain the layered graph model needed for zoom-level visualization.\n\nThis repository follows a plugin-based, clean architecture. Generate code that aligns with these boundaries."
    }
  ],
  "references": [
    "README.md",
    "ARCHITECTURE.md",
    "CONTEXT.md",
    "ROADMAP.md"
  ]
}